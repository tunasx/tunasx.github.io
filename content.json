{"meta":{"title":"Mr.Tunas","subtitle":"blog","description":"blog","author":"Mr.Tunas","url":"https://tunasx.github.io","root":"/"},"pages":[{"title":"about","date":"2020-03-05T09:16:27.000Z","updated":"2020-03-05T09:16:27.280Z","comments":true,"path":"about/index.html","permalink":"https://tunasx.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2020-03-05T10:41:39.000Z","updated":"2020-03-05T10:41:39.121Z","comments":true,"path":"friends/index.html","permalink":"https://tunasx.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-05T09:11:34.000Z","updated":"2020-03-05T09:12:04.771Z","comments":true,"path":"categories/index.html","permalink":"https://tunasx.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-03-05T09:12:44.000Z","updated":"2020-03-05T09:12:55.130Z","comments":true,"path":"tags/index.html","permalink":"https://tunasx.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"REDIS设计与实现笔记","slug":"Notes/Redis设计与实现笔记","date":"2020-03-06T14:39:33.961Z","updated":"2020-03-06T14:39:33.961Z","comments":true,"path":"2020/03/06/Notes/Redis设计与实现笔记/","link":"","permalink":"https://tunasx.github.io/2020/03/06/Notes/Redis%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"参考《redis设计与实现第二版》 redis版本： 2.9 数据结构和对象SDS简单动态字符串 二进制安全 除了可以保存文本文件外，还可以保存图片、音频、视频、压缩文件等二进制数据 遵循C字符串空字符结尾， 可直接重用部分C字符串库函数 长度获取 O(1) 杜绝缓存区内存溢出 减少字符串修改时的内存重分配次数 通过SDS的未使用空间，实现空间的预分配和惰性空间释放两种优化策略 1). 预分配: if sizeof(newStr) < 1MB free = sizeof(newStr) if sizeof(newStr) >= 1MB free = 1MB 2). 惰性空间释放 当需要缩短SDS的字符串长度是， 并不立即进行内存重分配来回收多余的内存， 而是使用free记录，以备将来使用 链表实现： 正常的双端链表 1234567891011121314151617181920// 链表的节点typedef struct listNode { struct listNode *prev; struct listNode *next; void *value;}listNode;// list结构持有链表，记录链表的一些属性和操作typedef struct list { listNode *head; listNode *tail; // 节点数量 unsigned long len; // 节点复制函数 void *(*dup)(void *ptr); // 节点对比函数 void (*free)(void *ptr); // 节点对比函数 int (*match)(void *ptr, void *ptr);}list; 特点 双端, 获取某个节点的前后节点时间复杂度O(1) 无环, 以NULL为终点 带表头和表尾指针，获取表头和表尾均为O(1) 带链表计数器，获取链表长度O(1) 多态 字典哈希表 1234567891011121314151617181920212223242526272829303132typedef struct dictht { dictEntry **table; unsigned long size; // 哈希表大小掩码 用户计算索引值 // 大小总是size - 1 unsigned long sizemask; // 记录哈希表的节点数量 unsigned long used;}dictht;typedef struct dictEntry { // 键 void *key; // 值 union { void *val; uint64_t u64; int64_t s64; } v; // 指向下一个哈希表节点，形成链表（解决冲突的方式） struct dictEntry *next;} dictEntry;typedef struct dict { // 类型特定函数 dictType *type; void *private; dictht ht[2]; // rehash索引 // 当rehash不在进行时，值为-1 int rehashindex;} Reids使用的hash计算算法：MurmurHash2 rehash当哈希表的负载因子到达一定程度时需要进行扩展和收缩rehash步骤 为ht[1]分配空间，大小根据要执行的操作来确定 如果是扩展操作，ht[1]的大小为第一个大于等于ht[0].used*2的2^n 如果是收缩操作，ht[1]的大小为第一个大于等于ht[0].used的2^n 将h[0]的所有键值对rehash到h[1]上面: rehash就是重新计算键的哈希值和索引值，然后将键值对放置在ht[1]哈希表的指定位置 当h[0]中的所有键值对都迁移到ht[1]后，释放h[0]，将h[1]设置为ht[0]，并在h[1]新创建一个空的哈希表，为下一次rehash做准备 哈希表的扩展和收缩时机负载因子计算： 12# 负载因子 = 哈希表已保存的节点数量 / 哈希表大小load_factor = ht[0].used / ht[0].size 下面任意条件满足会进行扩展： 服务器没有在执行BGSAVE或者BGREWRITEAOF，并且负载因子>=1 服务器正在执行BGSAVE或者BGREWRITEAOF，并且负载因子>=5当哈希表的负载因子","categories":[{"name":"notes","slug":"notes","permalink":"https://tunasx.github.io/categories/notes/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://tunasx.github.io/tags/Redis/"},{"name":"Note","slug":"Note","permalink":"https://tunasx.github.io/tags/Note/"},{"name":"Editing","slug":"Editing","permalink":"https://tunasx.github.io/tags/Editing/"}]},{"title":"Actor编程模型","slug":"编程模型/Actor编程模型","date":"2020-03-05T17:32:02.422Z","updated":"2020-03-05T17:32:02.422Z","comments":true,"path":"2020/03/06/编程模型/Actor编程模型/","link":"","permalink":"https://tunasx.github.io/2020/03/06/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/Actor%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Actors模型(Actor model)首先是由Carl Hewitt在1973定义， 由Erlang OTP (Open Telecom Platform) 推广，其消息传递更加符合面向对象的原始意图。 Actors属于并发组件模型 ，通过组件方式定义并发编程范式的高级阶段，避免使用者直接接触多线程并发或线程池等基础概念。 传统多数流行的语言并发是基于多线程之间的共享内存，使用同步方法防止写争夺，Actors使用消息模型，每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors，保证了单独写原则 。从而巧妙避免了多线程写争夺。 Actors模型的特点是： 隔离计算实体 “Share nothing” 没有任何地方同步 异步消息传递 不可变的消息 消息模型类似mailbox / queue AKKA框架是一个实现Actors模型的Scala或Java平台，灵感来自ERlang，能更轻松地开发可扩展，实现多线程安全应用。 Actors是一个轻量级的对象，通过发送消息实现交互。每个Actors在同一时间处理最多一个消息，可以发送消息给其他Actors。在同一时间可以于一个Java虚拟机存在数以百万计的参与者，构架是一个分层的父层（管理） - 子层，其中父层监控子层的行为。还可以很容易地扩展Actor运行在集群中各个节点之间 - 无需修改一行代码。每个演员都可以有内部状态（字段/变量） ，但通信只能通过消息传递，不会有共享数据结构（计数器，队列） 。Akka框架支持两种语言Java和Scala","categories":[{"name":"code","slug":"code","permalink":"https://tunasx.github.io/categories/code/"}],"tags":[{"name":"Actor","slug":"Actor","permalink":"https://tunasx.github.io/tags/Actor/"},{"name":"Erlang","slug":"Erlang","permalink":"https://tunasx.github.io/tags/Erlang/"}]},{"title":"CSP编程模型","slug":"编程模型/CSP编程模型","date":"2020-03-05T17:31:10.846Z","updated":"2020-03-05T17:31:10.846Z","comments":true,"path":"2020/03/06/编程模型/CSP编程模型/","link":"","permalink":"https://tunasx.github.io/2020/03/06/%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/CSP%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"待写作: go","categories":[{"name":"code","slug":"code","permalink":"https://tunasx.github.io/categories/code/"}],"tags":[{"name":"CSP","slug":"CSP","permalink":"https://tunasx.github.io/tags/CSP/"},{"name":"Golang","slug":"Golang","permalink":"https://tunasx.github.io/tags/Golang/"}]},{"title":"php-fpm 实现原理","slug":"PHP/php-fpm实现原理","date":"2020-03-05T17:26:40.318Z","updated":"2020-03-05T17:26:40.318Z","comments":true,"path":"2020/03/06/PHP/php-fpm实现原理/","link":"","permalink":"https://tunasx.github.io/2020/03/06/PHP/php-fpm%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/","excerpt":"","text":"cgi是服务器与后台语言交互的协议，有了这个协议，开发者可以使用任何语言处理服务器转发过来的请求，动态地生成内容，保证了传递过来的数据是标准格式的（规定了以什么样的格式传哪些数据（URL、查询字符串、POST数据、HTTP header等等）），方便了开发者。 fastcgi首先，FastCGI会先启一个master进程，解析配置文件，初始化执行环境，然后再启动多个worker进程。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着。当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是FastCGI的对进程的管理。 php-fpmmaster进程只有一个，负责监听端口，接收来自服务器的请求，而worker进程则一般有多个（具体数量根据实际需要配置），每个进程内部都嵌入了一个PHP解释器，是PHP代码真正执行的地方从FPM接收到请求，到处理完毕，其具体的流程如下1). FPM的master进程接收到请求。2). master进程根据配置指派特定的worker进程进行请求处理，如果没有可用进程，返回错误，这也是我们配合Nginx遇到502错误比较多的原因。3). worker进程处理请求，如果超时，返回504错误。4). 请求处理结束，返回结果。 php-fpm的配置文件说明123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081pid = run/php-fpm.pid#pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启 error_log = log/php-fpm.log#错误日志，默认在安装目录中的var/log/php-fpm.log log_level = notice#错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice. emergency_restart_threshold = 60emergency_restart_interval = 60s#表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。 process_control_timeout = 0#设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0. daemonize = yes#后台执行fpm,默认值为yes，如果为了调试可以改为no。在FPM中，可以使用不同的设置来运行多个进程池。这些设置可以针对每个进程池单独设置。 listen = 127.0.0.1:9000#fpm监听端口，即nginx中php处理的地址，一般默认值即可。可用格式为: ‘ip:port’, ‘port’, ‘/path/to/unix/socket’. 每个进程池都需要设置. listen.backlog = -1#backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考： http://www.3gyou.cc/?p=41 listen.allowed_clients = 127.0.0.1#允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接 listen.owner = wwwlisten.group = wwwlisten.mode = 0666#unix socket设置选项，如果使用tcp方式访问，这里注释即可。 user = wwwgroup = www#启动进程的帐户和组 pm = dynamic #对于专用服务器，pm可以设置为static。#如何控制子进程，选项有static和dynamic。如果选择static，则由pm.max_children指定固定的子进程数。如果选择dynamic，则由下开参数决定：pm.max_children #，子进程最大数pm.start_servers #，启动时的进程数pm.min_spare_servers #，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程pm.max_spare_servers #，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理 pm.max_requests = 1000#设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ’0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0. pm.status_path = /status#FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. munin监控会使用到 ping.path = /ping#FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。 ping.response = pong#用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong. request_terminate_timeout = 0#设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ’0′ 表示 ‘Off’.当经常出现502错误时可以尝试更改此选项。 request_slowlog_timeout = 10s#当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ’0′ 表示 ‘Off’ slowlog = log/$pool.log.slow#慢请求的记录日志,配合request_slowlog_timeout使用 rlimit_files = 1024#设置文件打开描述符的rlimit限制. 默认值: 系统定义值默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。 rlimit_core = 0#设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值. chroot =#启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用. chdir =#设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时） catch_workers_output = yes#重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空.","categories":[{"name":"php","slug":"php","permalink":"https://tunasx.github.io/categories/php/"}],"tags":[{"name":"php","slug":"php","permalink":"https://tunasx.github.io/tags/php/"},{"name":"php-fpm","slug":"php-fpm","permalink":"https://tunasx.github.io/tags/php-fpm/"},{"name":"cgi","slug":"cgi","permalink":"https://tunasx.github.io/tags/cgi/"},{"name":"fast-cgi","slug":"fast-cgi","permalink":"https://tunasx.github.io/tags/fast-cgi/"}]},{"title":"Hello World","slug":"hello-world","date":"2020-03-05T04:31:39.265Z","updated":"2020-03-05T04:31:39.265Z","comments":true,"path":"2020/03/05/hello-world/","link":"","permalink":"https://tunasx.github.io/2020/03/05/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}